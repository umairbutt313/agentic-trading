<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Stock Sentiment & Price Charts</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1e1e1e;
      color: #ffffff;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .stock-section {
      margin-bottom: 40px;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      background-color: #2a2e39;
    }
    
    .stock-title {
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: bold;
    }
    
    .chart-container {
      width: 100%;
      height: 400px;
      background-color: #131722;
      border-radius: 8px;
      margin-bottom: 20px;
      position: relative;
    }
    
    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .btn {
      background-color: #2962ff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    .btn:hover {
      background-color: #1e53e5;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .legend-color {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }
    
    .price-legend { background-color: #2962ff; }
    .sentiment-legend { background-color: #26a69a; }
    
    .status {
      text-align: center;
      padding: 10px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    
    .status.loading {
      background-color: #ffa726;
      color: #000;
    }
    
    .status.error {
      background-color: #ef5350;
    }
    
    .status.success {
      background-color: #26a69a;
    }
    
    .info-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .info-card {
      background-color: #2a2e39;
      padding: 20px;
      border-radius: 8px;
    }
    
    .info-card h3 {
      margin: 0 0 10px 0;
      color: #2962ff;
    }
    
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .chart-container {
        height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Multi-Stock Sentiment & Price Analysis</h1>
      <p>Interactive charts powered by TradingView Lightweight Charts</p>
    </div>
    
    <div id="status" class="status loading">Loading chart data...</div>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color price-legend"></div>
        <span>Stock Price Line (USD)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(41, 98, 255, 0.5);"></div>
        <span>Real-time Price Bars</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #76b900;"></div>
        <span>TradingView Sentiment</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #2196f3;"></div>
        <span>News Sentiment</span>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn" onclick="refreshAllData()">Refresh All Data</button>
      <button class="btn" onclick="resetAllZoom()">Reset All Zoom</button>
      <button class="btn" id="realtimeBtn" onclick="toggleRealTime()">Enable Real-Time</button>
      <button class="btn" onclick="toggleMarketStatus()">Market Status</button>
    </div>
    
    <div id="marketStatus" class="status" style="display: none;">
      <strong>Market Status:</strong> <span id="marketStatusText">Loading...</span> |
      <strong>WebSocket:</strong> <span id="websocketStatus">Disconnected</span> |
      <strong>Last Update:</strong> <span id="lastUpdateTime">Never</span>
    </div>

    <!-- NVIDIA Section -->
    <div class="stock-section">
      <div class="stock-title" style="color: #76b900;">NVIDIA (NVDA)</div>
      
      <h4 style="color: #2962ff; margin: 10px 0 5px 0;">üìà Real-time Price</h4>
      <div id="nvidiaPriceChart" class="chart-container"></div>
      
      <h4 style="color: #26a69a; margin: 20px 0 5px 0;">üì∞ Sentimental Analysis</h4>
      <div id="nvidiaSentimentChart" class="chart-container"></div>
    </div>

    <!-- Apple Section -->
    <div class="stock-section">
      <div class="stock-title" style="color: #a6a6a6;">Apple (AAPL)</div>
      
      <h4 style="color: #2962ff; margin: 10px 0 5px 0;">üìà Real-time Price</h4>
      <div id="applePriceChart" class="chart-container"></div>
      
      <h4 style="color: #26a69a; margin: 20px 0 5px 0;">üì∞ Sentimental Analysis</h4>
      <div id="appleSentimentChart" class="chart-container"></div>
    </div>

    <!-- Intel Section -->
    <div class="stock-section">
      <div class="stock-title" style="color: #0071c5;">Intel (INTC)</div>
      
      <h4 style="color: #2962ff; margin: 10px 0 5px 0;">üìà Real-time Price</h4>
      <div id="intelPriceChart" class="chart-container"></div>
      
      <h4 style="color: #26a69a; margin: 20px 0 5px 0;">üì∞ Sentimental Analysis</h4>
      <div id="intelSentimentChart" class="chart-container"></div>
    </div>
    
    <div class="info-panel">
      <div class="info-card">
        <h3>Latest Data Points</h3>
        <div id="latestData">Loading...</div>
      </div>
      <div class="info-card">
        <h3>Chart Statistics</h3>
        <div id="chartStats">Loading...</div>
      </div>
      <div class="info-card">
        <h3>Data Sources</h3>
        <div>
          <strong>Files:</strong> nvidia/apple/intel_score_price_dump.txt<br>
          <strong>Format:</strong> CSV (timestamp, score_sa_news, price)<br>
          <!-- Old format: CSV (timestamp, score_tradingview, score_sa_news, price) -->
          <strong>Active Sources:</strong> 2 (TradingView + News) <!-- Image sentiment removed --><br>
          <strong>Last Updated:</strong> <span id="lastUpdated">Loading...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- TradingView Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  
  <script>
    // Multi-chart configuration for separate price and sentiment charts
    const stocks = ['nvidia', 'apple', 'intel'];
    const stockColors = {
      nvidia: { price: '#76b900', sentiment: '#26a69a' },
      apple: { price: '#a6a6a6', sentiment: '#ff9800' },
      intel: { price: '#0071c5', sentiment: '#e91e63' }
    };
    
    let priceCharts = {};   // Separate charts for price data
    let sentimentCharts = {}; // Separate charts for sentiment data
    let chartData = {};
    
    // Initialize separate price and sentiment charts for all stocks
    function initCharts() {
      console.log('Initializing separate price and sentiment charts...');
      
      if (typeof LightweightCharts === 'undefined') {
        updateStatus('error', 'TradingView Lightweight Charts library not loaded');
        return;
      }
      
      stocks.forEach(stock => {
        try {
          // Create Price Chart
          const priceContainerId = stock + 'PriceChart';
          const priceContainer = document.getElementById(priceContainerId);
          
          if (!priceContainer) {
            console.error(`Price chart container not found: ${priceContainerId}`);
            return;
          }
          
          let containerWidth = priceContainer.clientWidth || 800;
          console.log(`Creating price chart for ${stock}, width: ${containerWidth}px`);
          
          // GITHUB FIX: Ensure container has dimensions before chart creation
          if (containerWidth === 0) {
            console.warn(`‚ö†Ô∏è ${stock} price container has zero width, setting default`);
            containerWidth = 800;
          }
          
          console.log(`üìä Creating ${stock} price chart with dimensions: ${containerWidth}x300`);
          
          const priceChart = LightweightCharts.createChart(priceContainer, {
            width: containerWidth,
            height: 300,
            autoSize: false, // GITHUB FIX: Disable autosize to ensure explicit dimensions
            layout: {
              backgroundColor: '#131722',
              textColor: 'rgba(255, 255, 255, 0.9)',
            },
            grid: {
              vertLines: { color: 'rgba(197, 203, 206, 0.1)' },
              horzLines: { color: 'rgba(197, 203, 206, 0.1)' },
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: {
              borderColor: 'rgba(197, 203, 206, 0.8)',
              scaleMargins: { top: 0.05, bottom: 0.05 },
              mode: 1,
              autoScale: true,
            },
            timeScale: {
              borderColor: 'rgba(197, 203, 206, 0.8)',
              timeVisible: true,
              secondsVisible: true,
            },
          });

          // Add price line series to price chart
          const priceSeries = priceChart.addLineSeries({
            color: stockColors[stock].price,
            lineWidth: 3,
            title: `${stock.toUpperCase()} Price (USD)`,
            priceFormat: {
              type: 'price',
              precision: 2,
              minMove: 0.01,
            },
          });

          // Create Sentiment Chart
          const sentimentContainerId = stock + 'SentimentChart';
          const sentimentContainer = document.getElementById(sentimentContainerId);
          
          if (!sentimentContainer) {
            console.error(`Sentiment chart container not found: ${sentimentContainerId}`);
            return;
          }
          
          console.log(`Creating sentiment chart for ${stock}, width: ${containerWidth}px`);
          
          console.log(`üìä Creating ${stock} sentiment chart with dimensions: ${containerWidth}x250`);
          
          const sentimentChart = LightweightCharts.createChart(sentimentContainer, {
            width: containerWidth,
            height: 250,
            autoSize: false, // GITHUB FIX: Disable autosize to ensure explicit dimensions
            layout: {
              backgroundColor: '#131722',
              textColor: 'rgba(255, 255, 255, 0.9)',
            },
            grid: {
              vertLines: { color: 'rgba(197, 203, 206, 0.1)' },
              horzLines: { color: 'rgba(197, 203, 206, 0.1)' },
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: {
              borderColor: 'rgba(197, 203, 206, 0.8)',
              scaleMargins: { top: 0.1, bottom: 0.1 },
              visible: true,
              // Set scale from 1-10 for sentiment scores
              mode: 0,
              autoScale: true,
            },
            timeScale: {
              borderColor: 'rgba(197, 203, 206, 0.8)',
              timeVisible: true,
              secondsVisible: true,
            },
          });

          // Set sentiment chart Y-axis range (1-10)
          sentimentChart.priceScale('right').applyOptions({
            scaleMargins: { top: 0.1, bottom: 0.1 },
            autoScale: true,
          });

          // // Add TradingView sentiment series - DISABLED
          // const tradingviewSeries = sentimentChart.addLineSeries({
          //   color: '#76b900', // Green for TradingView
          //   lineWidth: 2,
          //   title: `${stock.toUpperCase()} TradingView Sentiment`,
          //   priceFormat: {
          //     type: 'price',
          //     precision: 1,
          //     minMove: 0.1,
          //   },
          // });

          // Add News sentiment series
          const newsSeries = sentimentChart.addLineSeries({
            color: '#2196f3', // Blue for News
            lineWidth: 2,
            title: `${stock.toUpperCase()} News Sentiment`,
            priceFormat: {
              type: 'price',
              precision: 1,
              minMove: 0.1,
            },
          });

          // Store chart references
          priceCharts[stock] = {
            chart: priceChart,
            priceSeries: priceSeries,
          };
          
          sentimentCharts[stock] = {
            chart: sentimentChart,
            // tradingviewSeries: tradingviewSeries,  // DISABLED
            newsSeries: newsSeries,
          };

          // Make charts responsive
          window.addEventListener('resize', () => {
            const newWidth = priceContainer.clientWidth || 800;
            priceChart.applyOptions({ width: newWidth });
            sentimentChart.applyOptions({ width: newWidth });
          });
          
          console.log(`‚úÖ Charts created successfully for ${stock}`)
          
        } catch (error) {
          console.error(`‚ùå Error creating chart for ${stock}:`, error);
        }
      });
      
      console.log('Price charts initialized:', Object.keys(priceCharts));
      console.log('Sentiment charts initialized:', Object.keys(sentimentCharts));
    }
    
    // Helper function to convert hex to RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? 
        parseInt(result[1], 16) + ', ' + parseInt(result[2], 16) + ', ' + parseInt(result[3], 16) :
        '0, 0, 0';
    }

    // Load data for a specific stock
    async function loadStockData(stock) {
      try {
        console.log(`üîÑ Loading data for ${stock}`);
        
        // Map stock names to actual file names
        const fileMap = {
          'nvidia': 'nvidia_score_price_dump.txt',
          'apple': 'apple_score_price_dump.txt', 
          'intel': 'intel_score_price_dump.txt'
        };
        
        console.log(`üìÅ Fetching file: ${fileMap[stock]}`);
        const response = await fetch(`/${fileMap[stock]}?t=${Date.now()}`);
        console.log(`üì° Response status: ${response.status} ${response.statusText}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        const lines = csvText.trim().split('\n');
        console.log(`üìä Data file loaded: ${lines.length} lines`);
        
        if (lines.length < 2) {
          throw new Error(`No data found for ${stock}`);
        }
        
        // Skip header row
        const dataLines = lines.slice(1);
        const priceData = [];
        // const tradingviewSentiment = [];  // DISABLED
        const newsSentiment = [];
        // const imageSentiment = []; // REMOVED: Image sentiment disabled
        
        for (const line of dataLines) {
          // const [timestamp, score_tradingview, score_sa_news, price] = line.split(',');  // Old 4-column format
          const [timestamp, score_sa_news, price] = line.split(',');  // New 3-column format
          
          // IMPROVED: Better data validation based on Context7 guidance
          // if (!timestamp || !score_tradingview || !score_sa_news || !price) continue;  // Old validation
          if (!timestamp || !score_sa_news || !price) continue;  // New validation
          
          // Validate numeric values
          const priceValue = parseFloat(price);
          // const tvValue = parseFloat(score_tradingview);  // TradingView disabled
          const newsValue = parseFloat(score_sa_news);
          
          // if (isNaN(priceValue) || isNaN(tvValue) || isNaN(newsValue)) {  // Old validation
          if (isNaN(priceValue) || isNaN(newsValue)) {  // New validation without TradingView
            // console.warn(`‚ö†Ô∏è Skipping invalid data point:`, { timestamp, price, tvValue, newsValue });  // Old
            console.warn(`‚ö†Ô∏è Skipping invalid data point:`, { timestamp, price, newsValue });  // New
            continue;
          }
          
          // Convert ISO timestamp to Unix timestamp for TradingView
          const date = new Date(timestamp);
          if (isNaN(date.getTime())) {
            console.warn(`‚ö†Ô∏è Skipping invalid timestamp:`, timestamp);
            continue;
          }
          
          const time = Math.floor(date.getTime() / 1000);
          
          priceData.push({
            time: time,
            value: priceValue
          });
          
          // tradingviewSentiment.push({  // TradingView disabled
          //   time: time,
          //   value: tvValue
          // });
          
          newsSentiment.push({
            time: time,
            value: newsValue
          });
          
          // imageSentiment.push({  // REMOVED: Image sentiment disabled
          //   time: time,
          //   value: parseFloat(score_sa_image)
          // });
        }
        
        // Sort by time
        priceData.sort((a, b) => a.time - b.time);
        // tradingviewSentiment.sort((a, b) => a.time - b.time);  // DISABLED
        newsSentiment.sort((a, b) => a.time - b.time);
        // imageSentiment.sort((a, b) => a.time - b.time); // REMOVED: Image sentiment disabled
        
        console.log(`‚úÖ Parsed ${priceData.length} valid data points for ${stock}`);
        if (priceData.length > 0) {
          const prices = priceData.map(d => d.value);
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          console.log(`üí∞ Price range: $${minPrice.toFixed(2)} - $${maxPrice.toFixed(2)}`);
        }
        
        // FIXED: Update separate price and sentiment charts with proper error handling
        // console.log(`üìä Setting data for ${stock}: ${priceData.length} price points, ${tradingviewSentiment.length} TV sentiment, ${newsSentiment.length} news sentiment`);  // OLD
        console.log(`üìä Setting data for ${stock}: ${priceData.length} price points, ${newsSentiment.length} news sentiment`);
        
        try {
          if (priceCharts[stock] && priceData.length > 0) {
            priceCharts[stock].priceSeries.setData(priceData);
            console.log(`‚úÖ Price data set for ${stock}`);
          } else {
            console.warn(`‚ö†Ô∏è No price chart or data for ${stock}:`, { 
              hasChart: !!priceCharts[stock], 
              dataLength: priceData.length 
            });
          }
          
          // if (sentimentCharts[stock] && tradingviewSentiment.length > 0 && newsSentiment.length > 0) {  // OLD
          if (sentimentCharts[stock] && newsSentiment.length > 0) {
            // sentimentCharts[stock].tradingviewSeries.setData(tradingviewSentiment);  // DISABLED
            sentimentCharts[stock].newsSeries.setData(newsSentiment);
            console.log(`‚úÖ Sentiment data set for ${stock}`);
          } else {
            console.warn(`‚ö†Ô∏è No sentiment chart or data for ${stock}:`, { 
              hasChart: !!sentimentCharts[stock], 
              // tvLength: tradingviewSentiment.length,  // DISABLED
              newsLength: newsSentiment.length 
            });
          }
        } catch (error) {
          console.error(`‚ùå Error setting data for ${stock}:`, error);
        }
        
        // # COMMENTED OUT: Original fitContent approach - was not working reliably
        // # setTimeout(() => {
        // #   try {
        // #     if (priceCharts[stock]) {
        // #       priceCharts[stock].chart.timeScale().fitContent();
        // #       console.log(`üìà Price chart fitted for ${stock}`);
        // #     }
        // #     if (sentimentCharts[stock]) {
        // #       sentimentCharts[stock].chart.timeScale().fitContent();
        // #       console.log(`üì∞ Sentiment chart fitted for ${stock}`);
        // #     }
        // #   } catch (fitError) {
        // #     console.error(`‚ùå Error fitting charts for ${stock}:`, fitError);
        // #   }
        // # }, 200); // Increased timeout for better stability
        
        // NEW FIX: Force chart visibility and complete refresh
        forceChartVisibilityAndRefresh(stock);
          
        // COMMENTED OUT: Handle static price data (when markets are closed) 
        // TODO: This complex static price logic was preventing charts from displaying
        // Need to debug why setVisibleRange() causes display issues
        /* 
        if (priceData.length > 0 && priceCharts[stock]) {
          const prices = priceData.map(d => d.value);
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          const priceRange = maxPrice - minPrice;
          
          // Check if prices are truly static (identical values)
          const isStaticPrice = priceRange === 0;
          
          if (isStaticPrice) {
            console.log(`üîí ${stock} has static price: $${maxPrice.toFixed(2)} (market likely closed)`);
            
            // For static prices, create a visible horizontal line with appropriate scale
            const staticPrice = maxPrice;
            const buffer = staticPrice * 0.002; // 0.2% buffer for visibility
            
            // Set a narrow but visible price range
            priceCharts[stock].chart.priceScale('right').applyOptions({
              autoScale: false,
              mode: 2, // Percentage mode for better static price display
              scaleMargins: {
                top: 0.1,
                bottom: 0.1,
              },
              visible: true,
            });
            
            // Update the price series format for static price display
            priceCharts[stock].priceSeries.applyOptions({
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
              lineWidth: 4, // Thicker line for better visibility
              color: stockColors[stock].price,
              // Add crosshair marker to show exact price
              crosshairMarkerVisible: true,
              crosshairMarkerRadius: 6,
              priceLineVisible: true,
              lastValueVisible: true,
            });
            
            // Fit content to show the time range properly
            setTimeout(() => {
              priceCharts[stock].chart.timeScale().fitContent();
              
              // Set a visible price range manually
              priceCharts[stock].chart.priceScale('right').setVisibleRange({
                from: staticPrice - buffer,
                to: staticPrice + buffer,
              });
            }, 100);
            
          } else if (priceRange < maxPrice * 0.01) {
            // For small variations (< 1%), zoom in more aggressively  
            const margin = priceRange * 0.5 || maxPrice * 0.001;
            priceCharts[stock].chart.priceScale('right').applyOptions({
              autoScale: false,
              scaleMargins: {
                top: 0.01,
                bottom: 0.01,
              },
            });
            
            priceCharts[stock].priceSeries.applyOptions({
              priceFormat: {
                type: 'price',
                precision: 4,
                minMove: 0.0001,
              },
            });
            
            setTimeout(() => {
              priceCharts[stock].chart.timeScale().fitContent();
            }, 100);
            
            console.log(`üìä ${stock} has small price range: ${minPrice.toFixed(4)} - ${maxPrice.toFixed(4)} (${(priceRange/maxPrice*100).toFixed(4)}% variation)`);
          } else {
            // Normal price variation - use default scaling
            console.log(`üìà ${stock} has normal price range: ${minPrice.toFixed(2)} - ${maxPrice.toFixed(2)} (${(priceRange/maxPrice*100).toFixed(2)}% variation)`);
          }
        }
        */
        // END COMMENTED OUT STATIC PRICE HANDLING
          
        // Store data
          chartData[stock] = { 
            priceData, 
            // tradingviewSentiment,  // DISABLED
            newsSentiment, 
            // imageSentiment  // REMOVED: Image sentiment disabled 
          };
          
          // Check if we have static price data and update UI accordingly
          const prices = priceData.map(d => d.value);
          const isStaticPrice = prices.length > 1 && Math.min(...prices) === Math.max(...prices);
          
          if (isStaticPrice) {
            console.log(`üîí ${stock} loaded with static price: $${prices[0].toFixed(2)} (${priceData.length} points)`);
          } else {
            console.log(`üìà ${stock} loaded with dynamic prices: ${priceData.length} price points, 2 sentiment series`);
            console.log(`First 3 price points:`, priceData.slice(0, 3));
            console.log(`Last 3 price points:`, priceData.slice(-3));
          }
        // # REMOVED: Extra closing brace that was causing syntax error
        
      } catch (error) {
        console.error(`Error loading ${stock} data:`, error);
        updateStatus('error', `Error loading ${stock} data: ${error.message}`);
      }
    }

    // Load data for all stocks
    async function loadAllData() {
      updateStatus('loading', 'Loading chart data...');
      
      try {
        await Promise.all(stocks.map(stock => loadStockData(stock)));
        updateStatus('success', '‚úÖ All charts loaded successfully with real-time prices!');
        updateStatistics();
        
        // Auto-hide success message after 3 seconds
        setTimeout(() => {
          document.getElementById('status').style.display = 'none';
        }, 3000);
        
      } catch (error) {
        console.error('Error loading data:', error);
        updateStatus('error', 'Error loading chart data');
      }
    }

    // NEW FIX: Force chart visibility and complete refresh
    function forceChartVisibilityAndRefresh(stock) {
      console.log(`üîß Forcing visibility refresh for ${stock}`);
      
      // Multiple timeout attempts with increasing delays to ensure visibility
      const refreshAttempts = [100, 300, 500, 1000, 2000];
      
      refreshAttempts.forEach((delay, index) => {
        setTimeout(() => {
          try {
            const priceContainer = document.getElementById(stock + 'PriceChart');
            const sentimentContainer = document.getElementById(stock + 'SentimentChart');
            
            // Force container visibility check
            if (priceContainer) {
              const priceRect = priceContainer.getBoundingClientRect();
              console.log(`üîç ${stock} price container (attempt ${index + 1}): ${priceRect.width}x${priceRect.height}`);
              
              // Force resize if needed
              if (priceCharts[stock] && (priceRect.width > 0 && priceRect.height > 0)) {
                priceCharts[stock].chart.resize(priceRect.width, priceRect.height);
                priceCharts[stock].chart.timeScale().fitContent();
                console.log(`‚úÖ ${stock} price chart resized and fitted (attempt ${index + 1})`);
              }
            }
            
            if (sentimentContainer) {
              const sentRect = sentimentContainer.getBoundingClientRect();
              console.log(`üîç ${stock} sentiment container (attempt ${index + 1}): ${sentRect.width}x${sentRect.height}`);
              
              // Force resize if needed
              if (sentimentCharts[stock] && (sentRect.width > 0 && sentRect.height > 0)) {
                sentimentCharts[stock].chart.resize(sentRect.width, sentRect.height);
                sentimentCharts[stock].chart.timeScale().fitContent();
                console.log(`‚úÖ ${stock} sentiment chart resized and fitted (attempt ${index + 1})`);
              }
            }
            
            // Final attempt - force a complete refresh
            if (index === refreshAttempts.length - 1) {
              console.log(`üéØ Final refresh attempt for ${stock}`);
              if (priceCharts[stock] && sentimentCharts[stock]) {
                // Force redraw by temporarily changing and restoring a property
                const originalPriceWidth = priceCharts[stock].chart.chartElement().style.width;
                const originalSentWidth = sentimentCharts[stock].chart.chartElement().style.width;
                
                priceCharts[stock].chart.chartElement().style.width = '99%';
                sentimentCharts[stock].chart.chartElement().style.width = '99%';
                
                setTimeout(() => {
                  priceCharts[stock].chart.chartElement().style.width = originalPriceWidth;
                  sentimentCharts[stock].chart.chartElement().style.width = originalSentWidth;
                  
                  priceCharts[stock].chart.timeScale().fitContent();
                  sentimentCharts[stock].chart.timeScale().fitContent();
                  console.log(`üöÄ ${stock} force refresh completed`);
                }, 50);
              }
            }
          } catch (refreshError) {
            console.error(`‚ùå Error in visibility refresh for ${stock} (attempt ${index + 1}):`, refreshError);
          }
        }, delay);
      });
    }

    // Update status message
    function updateStatus(type, message) {
      const statusEl = document.getElementById('status');
      statusEl.className = `status ${type}`;
      statusEl.textContent = message;
      statusEl.style.display = 'block';
    }

    // Update statistics panel
    function updateStatistics() {
      let latestInfo = '';
      let statsInfo = '';
      
      stocks.forEach(stock => {
        if (chartData[stock] && chartData[stock].priceData.length > 0) {
          const latestPrice = chartData[stock].priceData[chartData[stock].priceData.length - 1];
          // const latestTv = chartData[stock].tradingviewSentiment[chartData[stock].tradingviewSentiment.length - 1];  // DISABLED
          const latestNews = chartData[stock].newsSentiment[chartData[stock].newsSentiment.length - 1];
          // const latestImage = chartData[stock].imageSentiment[chartData[stock].imageSentiment.length - 1]; // REMOVED: Image sentiment disabled
          
          // Check if price is static (all prices identical)
          const prices = chartData[stock].priceData.map(d => d.value);
          const isStatic = prices.length > 1 && Math.min(...prices) === Math.max(...prices);
          const priceIndicator = isStatic ? ' üîí' : ' üìà';
          
          latestInfo += `<strong>${stock.toUpperCase()}:</strong> $${latestPrice.value.toFixed(2)}${priceIndicator}<br>`;
          // latestInfo += `&nbsp;&nbsp;TV: ${latestTv.value.toFixed(1)} | News: ${latestNews.value.toFixed(1)}<br><br>`;  // OLD
          latestInfo += `&nbsp;&nbsp;News: ${latestNews.value.toFixed(1)}<br><br>`;  // Only news sentiment
          
          // Reuse the same prices array for statistics
          const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
          
          // const avgTv = chartData[stock].tradingviewSentiment.reduce((a, b) => a + b.value, 0) / chartData[stock].tradingviewSentiment.length;  // DISABLED
          const avgNews = chartData[stock].newsSentiment.reduce((a, b) => a + b.value, 0) / chartData[stock].newsSentiment.length;
          // const avgImage = chartData[stock].imageSentiment.reduce((a, b) => a + b.value, 0) / chartData[stock].imageSentiment.length; // REMOVED: Image sentiment disabled
          
          statsInfo += `<strong>${stock.toUpperCase()}:</strong> Price Avg: $${avgPrice.toFixed(2)}<br>`;
          // statsInfo += `&nbsp;&nbsp;Sentiment Avg: TV ${avgTv.toFixed(1)} | News ${avgNews.toFixed(1)}<br>`; // OLD
          statsInfo += `&nbsp;&nbsp;Sentiment Avg: News ${avgNews.toFixed(1)}<br>`; // Only news sentiment
          statsInfo += `&nbsp;&nbsp;Data Points: ${prices.length}<br><br>`;
        }
      });
      
      document.getElementById('latestData').innerHTML = latestInfo || 'No data loaded';
      document.getElementById('chartStats').innerHTML = statsInfo || 'No statistics available';
      document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
    }

    // Real-time WebSocket functionality
    let websocket = null;
    let isRealTimeEnabled = false;
    let autoRefreshInterval = null;
    let marketStatusVisible = false;

    // WebSocket connection for real-time updates
    function connectWebSocket() {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        return; // Already connected
      }

      try {
        // Try to connect to unified data service WebSocket
        websocket = new WebSocket('ws://localhost:8091/stream/NVDA');
        
        websocket.onopen = function(event) {
          console.log('WebSocket connected');
          updateWebSocketStatus('Connected', 'success');
          
          // Subscribe to all symbols
          const subscribeMessage = {
            type: 'subscribe',
            symbols: stocks.map(stock => stock.toUpperCase())
          };
          websocket.send(JSON.stringify(subscribeMessage));
        };

        websocket.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            if (data.status === 'success' && data.data_points) {
              updateChartWithRealTimeData(data);
              updateLastUpdateTime();
            }
          } catch (error) {
            console.error('WebSocket message error:', error);
          }
        };

        websocket.onclose = function(event) {
          console.log('WebSocket disconnected');
          updateWebSocketStatus('Disconnected', 'error');
          
          // Attempt to reconnect after 5 seconds if real-time is enabled
          if (isRealTimeEnabled) {
            setTimeout(connectWebSocket, 5000);
          }
        };

        websocket.onerror = function(error) {
          console.error('WebSocket error:', error);
          updateWebSocketStatus('Error', 'error');
        };

      } catch (error) {
        console.error('WebSocket connection failed:', error);
        updateWebSocketStatus('Failed to connect', 'error');
      }
    }

    function updateChartWithRealTimeData(data) {
      // Map company names back to stock keys
      const symbolToStock = {
        'NVDA': 'nvidia',
        'AAPL': 'apple', 
        'INTC': 'intel'
      };
      
      const stock = symbolToStock[data.symbol];
      if (!stock || (!priceCharts[stock] && !sentimentCharts[stock])) return;

      // Convert data points to chart format
      const priceData = [];
      // const tradingviewSentiment = [];  // DISABLED
      const newsSentiment = [];

      data.data_points.forEach(point => {
        const time = Math.floor(new Date(point.timestamp).getTime() / 1000);
        
        priceData.push({
          time: time,
          value: point.price
        });
        
        // tradingviewSentiment.push({  // DISABLED
        //   time: time,
        //   value: point.tradingview_sentiment
        // });
        
        newsSentiment.push({
          time: time,
          value: point.news_sentiment
        });
      });

      // Update separate price and sentiment charts
      if (priceCharts[stock]) {
        priceCharts[stock].priceSeries.setData(priceData);
      }
      
      if (sentimentCharts[stock]) {
        // sentimentCharts[stock].tradingviewSeries.setData(tradingviewSentiment);  // DISABLED
        sentimentCharts[stock].newsSeries.setData(newsSentiment);
      }

      console.log(`Updated ${stock} dual-panel charts with ${priceData.length} real-time data points`);
    }

    function updateWebSocketStatus(status, type) {
      const statusElement = document.getElementById('websocketStatus');
      if (statusElement) {
        statusElement.textContent = status;
        statusElement.className = type || '';
      }
    }

    function updateLastUpdateTime() {
      const timeElement = document.getElementById('lastUpdateTime');
      if (timeElement) {
        timeElement.textContent = new Date().toLocaleString();
      }
    }

    function updateMarketStatus() {
      const now = new Date();
      const day = now.getDay(); // 0 = Sunday, 6 = Saturday
      const hour = now.getHours();
      
      let marketStatus = 'Closed';
      let statusColor = '#ef5350';
      
      // Simple market hours check (9:30 AM - 4:00 PM ET, Monday-Friday)
      if (day >= 1 && day <= 5) { // Monday to Friday
        if (hour >= 9 && hour < 16) {
          marketStatus = 'Open';
          statusColor = '#26a69a';
        } else if ((hour === 9 && now.getMinutes() >= 30) || (hour === 16 && now.getMinutes() === 0)) {
          marketStatus = 'Open';
          statusColor = '#26a69a';
        } else if (hour < 9 || hour === 9 && now.getMinutes() < 30) {
          marketStatus = 'Pre-Market';
          statusColor = '#ffa726';
        } else {
          marketStatus = 'After-Hours';
          statusColor = '#ffa726';
        }
      }
      
      const statusElement = document.getElementById('marketStatusText');
      if (statusElement) {
        statusElement.textContent = marketStatus;
        statusElement.style.color = statusColor;
      }
    }

    // Auto-refresh functionality (fallback when WebSocket not available)
    function startAutoRefresh() {
      if (autoRefreshInterval) return;
      
      autoRefreshInterval = setInterval(() => {
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
          console.log('Auto-refreshing data (WebSocket not available)');
          loadAllData();
        }
      }, 30000); // Refresh every 30 seconds
    }

    function stopAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
    }

    // Control functions
    function refreshAllData() {
      loadAllData();
    }

    function resetAllZoom() {
      // # COMMENTED OUT: Original fitContent approach
      // # stocks.forEach(stock => {
      // #   if (priceCharts[stock]) {
      // #     priceCharts[stock].chart.timeScale().fitContent();
      // #   }
      // #   if (sentimentCharts[stock]) {
      // #     sentimentCharts[stock].chart.timeScale().fitContent();
      // #   }
      // # });
      
      // NEW FIX: Use force refresh approach for reset zoom
      console.log('üîÑ Resetting all chart zoom with force refresh');
      stocks.forEach(stock => {
        forceChartVisibilityAndRefresh(stock);
      });
    }

    function toggleRealTime() {
      const btn = document.getElementById('realtimeBtn');
      
      if (isRealTimeEnabled) {
        // Disable real-time
        isRealTimeEnabled = false;
        btn.textContent = 'Enable Real-Time';
        btn.style.backgroundColor = '#2962ff';
        
        if (websocket) {
          websocket.close();
        }
        stopAutoRefresh();
        
        updateStatus('success', 'Real-time updates disabled');
      } else {
        // Enable real-time
        isRealTimeEnabled = true;
        btn.textContent = 'Disable Real-Time';
        btn.style.backgroundColor = '#f44336';
        
        connectWebSocket();
        startAutoRefresh(); // Fallback auto-refresh
        
        updateStatus('success', 'Real-time updates enabled');
      }
    }

    function toggleMarketStatus() {
      const statusDiv = document.getElementById('marketStatus');
      marketStatusVisible = !marketStatusVisible;
      
      if (marketStatusVisible) {
        statusDiv.style.display = 'block';
        updateMarketStatus();
        // Update market status every minute
        setInterval(updateMarketStatus, 60000);
      } else {
        statusDiv.style.display = 'none';
      }
    }

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üöÄ DOM Content Loaded');
      
      // Check if TradingView library loaded
      if (typeof LightweightCharts === 'undefined') {
        console.error('‚ùå TradingView library not loaded');
        updateStatus('error', 'TradingView library failed to load from CDN');
        return;
      }
      console.log('‚úÖ TradingView library loaded:', LightweightCharts);
      
      // Check if containers exist
      stocks.forEach(stock => {
        const priceContainer = document.getElementById(stock + 'PriceChart');
        const sentimentContainer = document.getElementById(stock + 'SentimentChart');
        console.log(`üì¶ ${stock} containers:`, { 
          price: !!priceContainer, 
          sentiment: !!sentimentContainer,
          priceWidth: priceContainer?.clientWidth,
          sentimentWidth: sentimentContainer?.clientWidth
        });
      });
      
      // Allow DOM to fully render before creating charts
      setTimeout(() => {
        console.log('üìä Starting chart initialization...');
        initCharts();
        
        // Load data after charts are created
        setTimeout(() => {
          console.log('üìà Starting data loading...');
          loadAllData();
        }, 500); // Increased timeout
      }, 300); // Increased timeout
    });
  </script>
</body>
</html>